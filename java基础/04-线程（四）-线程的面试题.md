# 线程的面试题

## 1) 什么是线程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支 持，它也是一个很好的卖点。

## 2) 线程和进程有什么区别？

线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

## 3) Thread 类中的start() 和 run() 方法有什么区别？

这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。

## 4) Java中的volatile 变量是什么？

volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。

## 5) 什么是线程安全？Vector是一个线程安全类吗？

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。

## 6) wait()和sleep()比较

共同点： 1). 他们都是在多线程的环境下，sleep()方法和对象的wait()方法都可以让线程暂停执行，都可以在程序
的调用处阻塞指定的毫秒数，并返回。 2). wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态 ，从而
使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用
interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中
直接return即可安全地结束线程。 需要注意的是，InterruptedException是线程自己从内部抛出的，并不是
interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会
抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出
InterruptedException 。
不同点： 1). Thread类的方法：sleep(),yield()等 Object类的方法：wait()和notify()等 2). 每个对象都有一个锁来控
制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep()方法让当前线程暂停执行指
定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，休眠结束后线程会自动回到就绪状态;
wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的
notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象
的锁就可以进入就绪状态。 3). wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可
以在任何地方使用 4). sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 所以sleep()和wait()方法的
最大区别是： sleep()睡眠时，保持对象锁，仍然占有该锁； 而wait()睡眠时，释放对象锁。 但是wait()
和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议
使用该方法）。

## 7) sleep()方法和yield()方法有什么区别？

① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只
会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行
yield()方法后转入就绪（ready）状态； ③ sleep()方法需要声明抛出InterruptedException，而yield()方法没有声
明任何异常； ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

## 8) 线程类的一些常用方法：

sleep(): 强迫一个线程睡眠Ｎ毫秒，是一个静态方法，调用此方法要处理InterruptedException异常；
join(): 让一个线程等待另一个线程完成才继续执行；
yeild(): 线程让步，暂停当前正在执行的线程对象让出CPU资源，将当前线程从运行状态转换到就绪状态并执
行其他优先级相同或更高的线程；
isAlive(): 判断一个线程是否存活。
activeCount(): 程序中活跃的线程数。
enumerate(): 枚举程序中的线程。
currentThread(): 得到当前线程。
isDaemon(): 一个线程是否为守护线程。
setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结
束而结束)
setName(): 为线程设置一个名称。
setPriority(): 设置一个线程的优先级。
wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线
程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获
得锁的线程才能进入就绪状态； 