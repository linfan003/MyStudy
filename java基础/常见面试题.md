# 1.String、StringBuffer、StringBuilder

**String**

可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了存储数值**不可改变的字符串**。String 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以 String 对象是不可变的。每次对String进行改变时，都会产生一个新的String对象。

而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。在改变时都是对其原有对象进行操作，不会产生对象。

StringBuilder 是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。

如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用或者变量的内容不断变化，那么最好用 StringBuffer。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 String
2. 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

# 2.abstract class和interface的区别

## 相同点：

两者都是抽象类，都不能实例化。interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。

## 不同点

两种的语法区别 

1. 抽象类可以有构造方法，接口不能有构造方法 

2. 抽象类中可以有普通成员变量，接口中没有普通成员变量 

3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须是抽象的，不能有非抽象的普通方法 

4. 抽象类中抽象方法的访问类型可以是public，protected和默认类型虽然（eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型，并且默认即为public abstract类型 

5. 抽象类中可以包含静态方法，接口中不能包含静态方法
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型 

7. 一个类可以实现多个接口，但只能继承一个抽象类

## 两者在应用上的区别 

接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用

# 3. Java中实现多态的机制

java中实现多态的机制是依靠父类或接口的引用指向子类。从而实现了一个对象多种形态的特性。其中父类的引用是在程序运行时动态的指向具体的实例，调用该引用的方法时，不是根据引用变量的类型中定义的方法来运行，而是根据具体的实例的方法。

# 4. final,finally,finalize的区别?

final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。 

finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 

finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

# 5.Overload和Override的区别

答：Overload：顾名思义，就是Over(重新)——load（加载），所以中文名称是重载。它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。

Override：就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。

方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。

# 6. == 和 equals 的区别？

 值类型是存储在内存中的堆栈（以后简称栈）

而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。

== 操作比较的是两个变量的值是否相等 ，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。

 equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。

== 比较的是2个对象的地址，而equals比较的是2个对象的内容。显然，当equals为true时，==不一定为true。

# 7.&和&&的区别?

## 相同点

&与&&都可以用作逻辑与的运算符，当两边的结果都为true时，运算结果才为true，否则只要有一方运算结果是false，运算结果就为false。

## 不同点

&&在开发过程中用到的概率比&大，以为&&具有短路的功能，只要第一个表达式是false，就不会再进行判断。

# 8.hashCode（）与equals（）

1. 如果两个对象相等，则hashcode一定也是相同的
2. 两个对象相等,对两个equals方法返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖
5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。