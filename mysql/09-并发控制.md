# 锁

锁是计算机协调各个进程或线程并发访问某一资源的机制。

在数据库中，如传统的计算资源（如CPU、RAM、I/O等）的争用外，数据也是一种供多许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

# 1.并发控制

产生原因：多个查询需要在同一时刻修改数据。

# 2.读写锁

## 2.1读锁（共享锁）

读锁是共享的，或者说是互相不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。

## 2.2写锁（排他锁）

写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。这样能保证在给定的时间里，只有一个用户执行写入，并防止其他用户读取正在写入的同一资源。

# 3.锁颗粒

## 3.1表级锁定（table-level） 

表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。

该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。 当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。 

使用表级锁定的主要是**MyISAM，MEMORY，CSV**等一些非事务性存储引擎。 

## 3.2行级锁定（row-level） 

行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。

由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。 虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。 使用行级锁定的主要是**InnoDB**存储引擎。 

### 行锁优化建议

- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁；
- 合理涉及索引，金莲那个缩小锁的范围；
- 尽可能较少检索条件，避免间隙锁；
- 尽量控制十五大小，减少锁定资源量和时间长度；
- 尽可能低级别事务隔离。

## 3.3页级锁定（page-level） 

页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。

页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。 使用页级锁定的主要是BerkeleyDB存储引擎。 

总的来说，MySQL这3种锁的特性可大致归纳如下： 

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；     

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；

行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 

